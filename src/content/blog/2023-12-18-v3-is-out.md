---
title: "date-fns v3 is out!"
description: ""
pubDate: "18 Dec 2023"
---

üéâ After many months of development, v3 is out!

For most developers, upgrading won‚Äôt require any changes. For a few, it will be pretty trivial.

However, the release brings tons of good stuff, so for the starter, here‚Äôs a quick overview of the most notable changes:

- The library is now 100% TypeScript with brand-new handcrafted types.
- ESM support for Node.js.
- Support for Date class extensions like [UTCDate](https://github.com/date-fns/utc).
- Removed arguments checking and conversion code from all functions, except for formatting and parsing, which resulted in a smaller minimal build size.
- String date arguments are not back!
- No more IE support.
- New flat library structure improving DX for ESM/Deno (`node_modules/date-fns/add.mjs`).
- All functions now export via named exports, improving compatibility with different setups.

If you want to jump right into it, [see the v3.0.0 change log](https://date-fns.org/v3.0.0/docs/Change-Log#3.0.0-2023-12-18).

In this blog post I'll explain the changes in a bit more detail and also give you some context for the choices we made working on v3.

## TypeScript support

This release started as a rewrite to TypeScript. When I started working on the library in 2014, TypeScript seemed a niche project.

Since then the world has changed and most of the developers realized the power of types and largely adopted the language.

In date-fns types were an afterthough generated from JSDoc. I didn't really understand how it works and over the years, the generated types become 23K LOC monster with no hope for an easy fix.

To make sure date-fns provides first-class TypeScript support we decided to rewrite hundreds of functions to TypeScript. We carefully handcrafted every type and interface. We exported everything including options interfaces for every function.

It took a while, but with the help of the community it happened and I'm very proud of the result.

## Asd

The big theme of major date-fns releases is fixing the mistakes we made in the previous ones.

When working on the v1 API, we drew inspiration from many places, from Moment.js to Ruby on Rails. It resulted in an inconsistent API and approach to dealing with edge cases. So, when the time came, we decided to rework the library from the ground up, reviewing every bit of a hundred functions. I decided to take the most conservative route, between developer experience and making the API error-proof, always choosing the latter. We would use an existing standard, replacing familiar JS patterns where we could.

Back in the time, JavaScript fatigue was a big topic. New library versions, often incompatible, would be released every few months, making users endlessly refactor their work to keep their dependencies working. Since we had to make significant breaking changes, we packed changes worth a few major versions in a single release.

All that, of course, backfired. All started in long development cycles and endless ‚Äúany updates,‚Äù ‚Äúwhat‚Äôs the ETA‚Äù (and other less ‚Äúpolite‚Äù) comments. Many breaking changes, especially the ones that degraded the developer experience in favor of the ‚Äúbest‚Äù approach, caused an overwhelming amount of (justified) critique. Another side effect is that because of many guardrails, the library build size increased.

While it was worth it, as in the end, we got extremely consistent API, in v3, I decided to take a step back and make the API more developer-friendly. Having time to reflect, I now see which trade-offs were the least efficient.

Also, while having many ideas for improving the library that require breaking changes, I decided to focus on a few and make smaller, iterative steps.

The biggest (but invisible for the most) change is that we, with the help of the community, rewrote the library to TypeScript.

## Strings as arguments

In v2, we removed strings as arguments. Now they are back.

My reasoning for the removal was that passing an invalid string and expecting it to get parsed correctly was a common mistake. Another widespread issue was passing the date without time and getting UTC midnight instead of the local timezone, causing bugs in the user code. In both cases, the developers would blame date-fns, putting the support burden on us.

However, it did not solve the issue for users. They would wrap strings in `new Date` before passing them to the library and get the bug anyway. But then thousands of developers had to change every function call that involved strings when migrating from v1 to v2, often missing a few places when working without types and getting bugs. Also, the new developers had extra friction working with the library.

I admit my mistake, and now the strings are back. It might cause an influx of new issues, but I‚Äôll deal with them separately.

## Exceptions

To mitigate missing validation I added new class `Interval` that reimplements the validation logic that previously was
